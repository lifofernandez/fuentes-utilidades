#!/usr/bin/env python
""" Glyph Plot

Some UFO monitoring
por: lisandro fernandez

"""

from robofab.world import RFont, RGlyph
import argparse, robofab, math, sys
import matplotlib.pyplot as pyplot
from matplotlib.path import Path
import matplotlib.patches as patches


######
# robofab point type to matplotlib path code maping
# http://matplotlib.org/api/path_api.html

pType2cCode = {
	'stop': 0,
	'move': 1,
	'line': 2,
	'offcurve': 3,
	#'offcurve': 4,
	'curve': 4,
	'close': 79,
}


######
# Args handling 

parser = argparse.ArgumentParser()
parser.add_argument(
	"ufo_in",
	help = "the ufo file to process"
)
parser.add_argument(
	"glyph",
	help = "the glyph to plot"
)
parser.add_argument(
	"-v", "--verbose",
	help = "increase output verbosity",
	action = "store_true"
)
args = parser.parse_args()

path = args.ufo_in
g = args.glyph


######
# Font load and gliph Process

font = RFont(path)


if font == None:
	print "You should open a font first, there's nothing to look at now!"
else:
	print "The current font is:",font.info.postscriptFullName
	if args.verbose:
		print "the number of glyphs:", len(font)
		print "full name of this font:", font.info.postscriptFullName
		print 'ascender:', font.info.ascender
		print 'descender:', font.info.descender
		print '-----'
		print "list of glyph names:", font.keys()
		print '-----'

# for g in [glyph.name for glyph in font]:

	glyph = font[g]
	print 'Glypho:', g 
	
	pen = glyph.getPointPen()
	for contour in glyph:
		path_data = []
		for point in contour.points:
			pathCode = pType2cCode[point.type]
			p = (pathCode, (point.x,point.y))
			path_data.append(p);
			if args.verbose:
				print point.type+':', point.x,point.y


######
# matplotlib stuff

fig, ax = pyplot.subplots()

codes, verts = zip(*path_data)
path = Path(verts, codes)
patch = patches.PathPatch(
	path,
	facecolor='r',
	alpha=0.5
)
ax.add_patch(patch)

# plot control points and connecting lines
x, y = zip(*path.vertices)
line, = ax.plot(x, y, 'go-')

ax.grid()
ax.axis('equal')
pyplot.show()

